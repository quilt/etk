<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>EVM Toolkit (ETK)</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">EVM Toolkit</a></li><li class="chapter-item expanded "><a href="ch01-cli/index.html"><strong aria-hidden="true">1.</strong> Command-Line Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-cli/ch01-eas.html"><strong aria-hidden="true">1.1.</strong> eas</a></li><li class="chapter-item expanded "><a href="ch01-cli/ch02-disease.html"><strong aria-hidden="true">1.2.</strong> disease</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-lang/index.html"><strong aria-hidden="true">2.</strong> Language &amp; Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-lang/ch01-instructions.html"><strong aria-hidden="true">2.1.</strong> Instructions</a></li><li class="chapter-item expanded "><a href="ch02-lang/ch02-expressions.html"><strong aria-hidden="true">2.2.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="ch02-lang/ch03-labels.html"><strong aria-hidden="true">2.3.</strong> Labels</a></li><li class="chapter-item expanded "><a href="ch02-lang/ch04-macros/index.html"><strong aria-hidden="true">2.4.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-lang/ch04-macros/ch01-builtins.html"><strong aria-hidden="true">2.4.1.</strong> Built-In</a></li><li class="chapter-item expanded "><a href="ch02-lang/ch04-macros/ch02-expression.html"><strong aria-hidden="true">2.4.2.</strong> Expression Macros</a></li><li class="chapter-item expanded "><a href="ch02-lang/ch04-macros/ch03-instruction.html"><strong aria-hidden="true">2.4.3.</strong> Instruction Macros</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.5.</strong> Examples</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">EVM Toolkit (ETK)</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/quilt/etk" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="evm-toolkit-etk"><a class="header" href="#evm-toolkit-etk">EVM Toolkit (ETK)</a></h1>
<p>The <strong>EVM Toolkit</strong> (or <em>ETK</em>) is a collection of tools for creating and analyzing smart contract programs on the <a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine</a>. So far it consists of an assembler (<code>eas</code>) and a disassembler (<code>disease</code>).</p>
<p>ETK is new, and highly experimental. Use at your own risk.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<h3 id="assembler-eas"><a class="header" href="#assembler-eas">Assembler: <code>eas</code></a></h3>
<p>The assembler lives in the <a href="https://crates.io/crates/etk-asm"><code>etk-asm</code></a> crate, and provides a command-line interface (<code>eas</code>) and a Rust library. The assembler has a couple notable features:</p>
<ul>
<li>Importing multiple files into the same scope, for organization.</li>
<li>Including files in a separate scope, for constructors and initialization code.</li>
<li>Automatic push size selection.</li>
<li><a href="https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector">Solidity-style function selectors</a>.</li>
</ul>
<h3 id="disassembler-disease"><a class="header" href="#disassembler-disease">Disassembler: <code>disease</code></a></h3>
<p>The disassembler lives in the <a href="https://crates.io/crates/etk-dasm"><code>etk-dasm</code></a> crate, and also provides a command-line interface (<code>disease</code>) and a Rust library. The disassembler is much more experimental, and has a limited set of features:</p>
<ul>
<li>Disassemble hex or binary encoded instructions into their mnemonics.</li>
<li>Identify basic blocks.</li>
</ul>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>Alongside this book, you can also read the API docs generated by Rustdoc if you would like to use ETK as a library.</p>
<ul>
<li><a href="https://docs.rs/etk-asm">etk-asm</a></li>
<li><a href="https://docs.rs/etk-dasm">etk-dasm</a></li>
<li><a href="https://docs.rs/etk-analyze">etk-analyze</a></li>
</ul>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p><code>ecfg</code> requires z3 to build
Ubuntu Installation Instructions (example):</p>
<pre><code class="language-console">sudo apt-get update -y
sudo apt-get install -y z3
</code></pre>
<p>Check the system logs to confirm that there are no related errors.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>ETK, all the source code, is released under the <a href="https://raw.githubusercontent.com/quilt/etk/master/LICENSE-APACHE">Apache License Version 2.0</a> and under the <a href="https://raw.githubusercontent.com/quilt/etk/master/LICENSE-MIT">MIT License</a>.</p>
<h1 id="command-line-tools"><a class="header" href="#command-line-tools">Command-Line Tools</a></h1>
<p>ETK provides a set of command-line tools, and can also be used as Rust crates. Let's dive into the command line tools first.</p>
<h2 id="install-from-source"><a class="header" href="#install-from-source">Install from Source</a></h2>
<p>ETK and its tools can be installed by compiling the source code on your local machine.</p>
<h3 id="pre-requisite"><a class="header" href="#pre-requisite">Pre-requisite</a></h3>
<p>ETK is written in <a href="https://www.rust-lang.org/">Rust</a> and needs to be compiled with <strong>cargo</strong>. The minimum supported Rust version <code>1.51</code>. If you don't have Rust installed, <a href="https://www.rust-lang.org/tools/install">install</a> it now.</p>
<h3 id="install-development-version"><a class="header" href="#install-development-version">Install Development Version</a></h3>
<p>The development version contains all the latest features, bugs, and maybe even some bug-fixes that will eventually be released in the next version. If you can't wait for the next release, you can install the development version from git yourself.</p>
<p>Open a terminal and use cargo to install ETK:</p>
<pre><code class="language-bash">cargo install \
    --git 'https://github.com/quilt/etk' \
    --features cli \
    etk-asm \
    etk-dasm
</code></pre>
<h3 id="install-released-version"><a class="header" href="#install-released-version">Install Released Version</a></h3>
<p>Once you have Rust and cargo installed, you just have to type this snippet in your terminal:</p>
<pre><code class="language-bash">cargo install --features cli etk-asm etk-dasm
</code></pre>
<h2 id="install-from-binaries"><a class="header" href="#install-from-binaries">Install from Binaries</a></h2>
<p>Precompiled binaries will be provided for select platforms on a best-effort basis. Visit <a href="https://github.com/quilt/etk/releases">the releases page</a> to download the appropriate version, once we create one, for your platform.</p>
<h2 id="install-syntax-highlighting"><a class="header" href="#install-syntax-highlighting">Install Syntax Highlighting</a></h2>
<p>Syntax highlighting for <code>vim</code> is available via <a href="https://github.com/quilt/vim-etk"><code>vim-etk</code></a>.</p>
<h1 id="assembler-eas-1"><a class="header" href="#assembler-eas-1">Assembler: <code>eas</code></a></h1>
<p>The assembler command converts human-readable mnemonics (ex. <code>push2</code>, <code>caller</code>) into the raw bytes the EVM interpreter expects, encoded in hexadecimal. In addition to this conversion, the assembler performs transformations on the source in the form of expression- and instruction- macros, which we'll get into later.</p>
<p>Invoking the assembler is pretty simple:</p>
<pre><code class="language-bash">eas input.etk output.hex
</code></pre>
<p>The input argument (<code>input.etk</code> here) is the path to an assembly file, and is required. <code>output.hex</code> is the path where the assembled instructions will be written, encoded in hex. If the output path is omitted, the assembled instructions are written to the standard output.</p>
<h2 id="a-note-on-paths"><a class="header" href="#a-note-on-paths">A Note on Paths</a></h2>
<p>The input argument determines the <em>root</em> of the project. If <code>/home/user/foobar/main.etk</code> is the input argument, the root would be <code>/home/user/foobar</code>. Only files within the root directory can be included or imported.</p>
<h1 id="disassembler-disease-1"><a class="header" href="#disassembler-disease-1">Disassembler: <code>disease</code></a></h1>
<p>The disassembler command <code>disease</code> is roughly the inverse of the assembler. It transforms a string of bytes into human-readable mnemonics.</p>
<p>The basic invocation of <code>disease</code> looks like:</p>
<pre><code class="language-bash">disease --bin-file contract.bin         # Disassemble a binary file
disease --hex-file contract.hex         # Disassemble a hexadecimal file
disease --code 0x5b600056               # Disassemble the command line argument
</code></pre>
<h2 id="specifying-input"><a class="header" href="#specifying-input">Specifying Input</a></h2>
<h3 id="--bin-file-or--b"><a class="header" href="#--bin-file-or--b"><code>--bin-file</code>, or <code>-b</code></a></h3>
<p>When you use the <code>--bin-file</code> argument, <code>disease</code> will read the code from the specified file, and interpret it as raw binary bytes. Few tools use this format.</p>
<h3 id="--hex-file-or--x"><a class="header" href="#--hex-file-or--x"><code>--hex-file</code>, or <code>-x</code></a></h3>
<p>With the <code>--hex-file</code> argument, the specified file is instead interpreted as hexadecimal.</p>
<h3 id="--code-or--c"><a class="header" href="#--code-or--c"><code>--code</code>, or <code>-c</code></a></h3>
<p>Great for short snippets, the <code>--code</code> argument instructs <code>disease</code> to disassemble the hexadecimal string given directly on the command line.</p>
<h2 id="specifying-output"><a class="header" href="#specifying-output">Specifying Output</a></h2>
<h3 id="--out-file-or--o"><a class="header" href="#--out-file-or--o"><code>--out-file</code>, or <code>-o</code></a></h3>
<p>If provided, <code>--out-file</code> causes the disassembled source to be written to the given path. Without <code>--out-file</code>, the disassembly is written to the standard output.</p>
<h1 id="language--syntax"><a class="header" href="#language--syntax">Language &amp; Syntax</a></h1>
<p>The ETK assembly language takes inspiration from <a href="https://www.nasm.us/">NASM</a> and other similar assemblers, but has its own particular flavor.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<h3 id="friendly-example"><a class="header" href="#friendly-example">Friendly Example</a></h3>
<p>This example should increment a value from 0 to 255 on the stack, then halt execution.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push1 0x00

loop:
    jumpdest
    push1 0x01
    add
    dup1
    push1 0xFF
    gt
    push1 loop
    jumpi

pop
stop                # This halts execution
<span class="boring">&quot;#;
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(Vec::new());
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>The first line—<code>push1 0x00</code>—describes a push instruction of length one, with a value of <code>0</code>. When assembled, this line would become <code>0x6000</code>.</p>
<p>Next, we have <code>loop:</code>, which introduces a label named <em>loop</em>. Labels can be used as arguments to push instructions, usually for jumps or subroutines.</p>
<p>Finally, we have <code># This halts execution</code>, which is a comment. Comments are introduced with <code>#</code> and continue to the end of the line. Comments are ignored as far as the assembler is concerned.</p>
<p>There are a couple other features, like macros, which will be covered in later chapters.</p>
<h3 id="formal-syntax"><a class="header" href="#formal-syntax">Formal Syntax</a></h3>
<p>For the language nerds, the ETK assembly language syntax is defined by the following <a href="https://pest.rs/">Pest</a> grammar:</p>
<pre><code class="language-pest">///////////////////////
// program structure //
///////////////////////
program = _{ SOI ~ inner ~ EOI }
inner = _{ NEWLINE* ~ (stmt ~ (NEWLINE+|&quot;;&quot;))* ~ stmt? }
stmt = _{ label_definition | builtin | local_macro | push | op }

//////////////////////
// opcode mnemonics //
//////////////////////
op = @{
	&quot;origin&quot; | &quot;stop&quot; | &quot;mulmod&quot; | &quot;mul&quot; | &quot;sub&quot; | &quot;div&quot; | &quot;sdiv&quot; | &quot;mod&quot; | &quot;smod&quot; |
	&quot;addmod&quot; | &quot;exp&quot; | &quot;signextend&quot; | &quot;lt&quot; | &quot;gt&quot; | &quot;slt&quot; |
	&quot;sgt&quot; | &quot;eq&quot; | &quot;iszero&quot; | &quot;and&quot; | &quot;or&quot; | &quot;xor&quot; | &quot;not&quot; | &quot;shl&quot; | &quot;shr&quot; |
	&quot;sar&quot; | &quot;keccak256&quot; | &quot;address&quot; | &quot;add&quot; | &quot;balance&quot; | &quot;caller&quot; |
	&quot;callvalue&quot; | &quot;calldataload&quot; | &quot;calldatasize&quot; | &quot;calldatacopy&quot; |
	&quot;codesize&quot; | &quot;codecopy&quot; | &quot;gasprice&quot; | &quot;extcodesize&quot; | &quot;extcodecopy&quot; |
	&quot;returndatasize&quot; | &quot;returndatacopy&quot; | &quot;extcodehash&quot; | &quot;blockhash&quot; |
	&quot;coinbase&quot; | &quot;timestamp&quot; | &quot;number&quot; | &quot;difficulty&quot; | &quot;gaslimit&quot; |
	&quot;pop&quot; | &quot;mload&quot; | &quot;mstore8&quot; | &quot;mstore&quot; | &quot;sload&quot; | &quot;sstore&quot; | &quot;jumpdest&quot; |
	&quot;jumpi&quot; | &quot;jump&quot; | &quot;pc&quot; | &quot;msize&quot; | &quot;gas&quot; | swap | dup | log |
	&quot;create2&quot; | &quot;callcode&quot; | &quot;call&quot; | &quot;return&quot; | &quot;delegatecall&quot; | &quot;create&quot; |
	&quot;staticcall&quot; | &quot;revert&quot; | &quot;selfdestruct&quot; | &quot;byte&quot; | &quot;chainid&quot; | &quot;selfbalance&quot; |
	&quot;basefee&quot; | &quot;invalid&quot; | &quot;push0&quot; | &quot;mcopy&quot;
}
push = ${ &quot;push&quot; ~  word_size ~ WHITESPACE ~ expression }
swap = @{ &quot;swap&quot; ~ half_word_size }
dup  = @{ &quot;dup&quot; ~ half_word_size }
log = @{ &quot;log&quot; ~ '0'..'4' }

word_size = @{ ('1'..'2' ~ '0'..'9') | (&quot;3&quot; ~ '0'..'2') | '1'..'9' }
half_word_size = @{ (&quot;1&quot; ~ '0'..'6') | '1'..'9' }

////////////////////////
// instruction macros //
////////////////////////
instruction_macro_definition = { &quot;%macro&quot; ~ function_declaration ~ NEWLINE* ~ (instruction_macro_stmt ~ NEWLINE+)* ~ &quot;%end&quot; }
instruction_macro_stmt = _{ label_definition | &quot;%&quot; ~ push_macro | local_macro | push | op }
instruction_macro_variable = @{ &quot;$&quot; ~ function_parameter }
instruction_macro = !{ &quot;%&quot; ~ function_invocation }

local_macro = { !builtin ~ (instruction_macro_definition | instruction_macro  | expression_macro_definition) }
builtin = ${ &quot;%&quot; ~ ( import | include | include_hex | push_macro ) }

import = !{ &quot;import&quot; ~ arguments }
include = !{ &quot;include&quot; ~ arguments }
include_hex = !{ &quot;include_hex&quot; ~ arguments }
push_macro = !{ &quot;push&quot; ~ arguments }

arguments = _{ &quot;(&quot; ~ arguments_list? ~ &quot;)&quot; }
arguments_list = _{ ( argument ~ &quot;,&quot; )* ~ argument? }
argument = _{ string | expression }

string = @{ &quot;\&quot;&quot; ~ string_char* ~ &quot;\&quot;&quot; }
string_char = _{ &quot;\\\\&quot; | &quot;\\\&quot;&quot; | (!&quot;\\&quot; ~ !&quot;\&quot;&quot; ~ ANY) }

///////////////////////
// expression macros //
///////////////////////
expression_macro_definition = !{ &quot;%def&quot; ~ function_declaration ~ NEWLINE ~ expression ~ NEWLINE ~ &quot;%end&quot; }
expression_macro = { function_invocation }

selector = ${ &quot;selector(\&quot;&quot; ~ selector_function_declaration ~ &quot;\&quot;)&quot; }
topic = ${ &quot;topic(\&quot;&quot; ~ selector_function_declaration ~ &quot;\&quot;)&quot; }
selector_function_declaration = @{ function_name ~ &quot;(&quot; ~ function_parameter* ~ (&quot;,&quot; ~ function_parameter)* ~ &quot;)&quot; }
function_declaration = { function_name ~ &quot;(&quot; ~ function_parameter* ~ (&quot;,&quot; ~ function_parameter)* ~ &quot;)&quot; }
function_invocation = _{ function_name ~ &quot;(&quot; ~ expression* ~ (&quot;,&quot; ~ expression)* ~ &quot;)&quot; }
function_name = @{ ( ASCII_ALPHA | &quot;_&quot; ) ~ ( ASCII_ALPHANUMERIC | &quot;_&quot; )* }
function_parameter = @{ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* }

//////////////
// operands //
//////////////
number = _{ binary | octal | hex | decimal }

binary = @{ &quot;0b&quot; ~ ASCII_BIN_DIGIT+ }
octal = @{ &quot;0o&quot; ~ ASCII_OCT_DIGIT+ }
decimal = @{ ASCII_DIGIT+ }
hex = @{ &quot;0x&quot; ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT+ }

label = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | &quot;_&quot;)* }
label_definition = { label ~ &quot;:&quot; }

////////////////
// infix math //
////////////////
expression = !{ term ~ (operation ~ term)* }
term = _{ instruction_macro_variable | selector | topic | expression_macro | label | number | negative_decimal | &quot;(&quot; ~ expression ~ &quot;)&quot; }
negative_decimal = @{ &quot;-&quot; ~ ASCII_DIGIT+ }
operation = _{ plus | minus | times | divide }
plus = { &quot;+&quot; }
minus = { &quot;-&quot; }
times = { &quot;*&quot; }
divide = { &quot;/&quot; }

///////////////
// overrides //
///////////////
WHITESPACE = _{ &quot; &quot; | &quot;\t&quot; }
COMMENT = _{ &quot;#&quot; ~ (!NEWLINE ~ ANY)* }
</code></pre>
<h1 id="instructions"><a class="header" href="#instructions">Instructions</a></h1>
<p>Instructions, also known as opcodes or <code>Op</code>s internally, are the building blocks of ETK smart contracts. Each instruction has a human-readable mnemonic (like <code>dup3</code>) and the machine readable equivalent (which would be <code>0x82</code>). The <code>push</code> family of instructions also encode an immediate value (or argument.)</p>
<h2 id="list-of-instructions"><a class="header" href="#list-of-instructions">List of Instructions</a></h2>
<pre><code class="language-ignore">stop
add
mul
sub
div
sdiv
mod
smod
addmod
mulmod
exp
signextend

lt
gt
slt
sgt
eq
iszero
and
or
xor
not
byte
shl
shr
sar

keccak256

address
balance
origin
caller
callvalue
calldataload
calldatasize
calldatacopy
codesize
codecopy
gasprice
extcodesize
extcodecopy
returndatasize
returndatacopy
extcodehash
blockhash
coinbase
timestamp
number
difficulty
gaslimit
chainid
selfbalance
basefee

pop
mload
mstore
mstore8
sload
sstore
jump
jumpi
pc
msize
gas
jumpdest
mcopy

push1 0xAA
push2 0xAABB
push3 0xAABBCC
push4 0xAABBCCDD
push5 0xAABBCCDDEE
push6 0xAABBCCDDEEFF
push7 0xAABBCCDDEEFF00
push8 0xAABBCCDDEEFF0011
push9 0xAABBCCDDEEFF001122
push10 0xAABBCCDDEEFF00112233
push11 0xAABBCCDDEEFF0011223344
push12 0xAABBCCDDEEFF001122334455
push13 0xAABBCCDDEEFF00112233445566
push14 0xAABBCCDDEEFF0011223344556677
push15 0xAABBCCDDEEFF001122334455667788
push16 0xAABBCCDDEEFF00112233445566778899
push17 0xAABBCCDDEEFF00112233445566778899AA
push18 0xAABBCCDDEEFF00112233445566778899AABB
push19 0xAABBCCDDEEFF00112233445566778899AABBCC
push20 0xAABBCCDDEEFF00112233445566778899AABBCCDD
push21 0xAABBCCDDEEFF00112233445566778899AABBCCDDEE
push22 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF
push23 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF00
push24 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF0011
push25 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF001122
push26 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233
push27 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF0011223344
push28 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF001122334455
push29 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566
push30 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF0011223344556677
push31 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF001122334455667788
push32 0xAABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899
dup1
dup2
dup3
dup4
dup5
dup6
dup7
dup8
dup9
dup10
dup11
dup12
dup13
dup14
dup15
dup16
swap1
swap2
swap3
swap4
swap5
swap6
swap7
swap8
swap9
swap10
swap11
swap12
swap13
swap14
swap15
swap16
log0
log1
log2
log3
log4

create
call
callcode
return
delegatecall
create2

staticcall

revert
invalid
selfdestruct
</code></pre>
<h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<h2 id="push-opcodes"><a class="header" href="#push-opcodes"><code>push</code> opcodes</a></h2>
<p>The <code>push</code> family of instructions require an immediate argument. Unlike most arguments (which come from the stack), immediate arguments are encoded in the bytes <em>immediately</em> following the opcode.</p>
<p>For example, <code>push2 258</code> would assemble to <code>0x610102</code>. <code>0x61</code> is the instruction, and <code>0x0102</code> is the immediate argument. <code>push2</code> instructs the EVM to use the next two bytes <code>0x01</code> and <code>0x02</code> as input for the op. That value is left-padded with zeros to 32 bytes (so <code>0x0000...000102</code>) and placed on the stack.</p>
<p>While an assembled <code>push</code> must have a concrete value, it is often useful when developing a program to have the ability to manipulate the operand at compile time. For this reason, <code>push</code> opcodes take a single <strong>expression</strong> as their operand.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push1 1+(2*3)/4
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x02]);
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>An <strong>expression</strong> is a standard infix mathematical expression that is evaluated during assembly. Its computed value <em>must</em> fit within the preceding <code>push</code>'s size allowance (eg. less than 256 for <code>push8</code>). </p>
<h3 id="terms"><a class="header" href="#terms">Terms</a></h3>
<p>Many different types of values are allowed as a term in an expression:</p>
<h4 id="integer-literals"><a class="header" href="#integer-literals">Integer Literals</a></h4>
<p>Integer literals are described by the following Pest grammar:</p>
<pre><code class="language-ignore">number   = _{ binary | octal | hex | decimal | negative }
decimal  = @{ ASCII_DIGIT+ }
negative = @{ &quot;-&quot; ~ ASCII_DIGIT+ }
binary   = @{ &quot;0b&quot; ~ ASCII_BIN_DIGIT+ }
hex      = @{ &quot;0x&quot; ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT+ }
octal    = @{ &quot;0o&quot; ~ ASCII_OCT_DIGIT+ }
</code></pre>
<p>There is no limit for the length of integer literals. While expressions support
both signed and unsigned integers, the result of the expression must
non-negative and fit within the width of the corresponding <code>push</code> instruction.</p>
<h4 id="labels"><a class="header" href="#labels">Labels</a></h4>
<p>A <a href="ch02-lang/ch03-labels.html">label</a> may be used as a term in an expression.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>start:
    push1 start + 1
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x01]);
</span><span class="boring">}
</span></code></pre></pre>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<p><a href="ch02-lang/ch04-macros/ch02-expression.html">Expression macros</a> may be used as a term in an expression.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push4 selector(&quot;transfer(uint256,uint256)&quot;)
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x63, 12, 247, 158, 10]);
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<h4 id="binary"><a class="header" href="#binary">Binary</a></h4>
<p>Expressions support the following binary operators:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push1 1+2       # addition
push1 1*2       # multiplication
push1 2-1       # subtraction
push1 2/2       # division

<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x03, 0x60, 0x02, 0x60, 0x01, 0x60, 0x01]);
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="labels-1"><a class="header" href="#labels-1">Labels</a></h1>
<p>Manually counting out jump destination addresses would be a monumentally pointless task, so the assembler supports assigning names (or <em>labels</em>) to specific locations in code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>label0:             # &lt;- This is a label called &quot;label0&quot;,
                    #    and it has the value 0, since it is
                    #    before any instructions in scope.

    jumpdest
    push1 label0    # &lt;- Here we push the value of &quot;label0&quot;,
                    #    which is zero, onto the stack.

    jump            # Now we jump to zero, which is a
                    # `jumpdest` instruction, looping forever.
<span class="boring">&quot;#;
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(Vec::new());
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="uses"><a class="header" href="#uses">Uses</a></h2>
<p>The obvious (and only, currently) place to use a label is in a push instruction. That said, there are a couple interesting ways to use labels that might not be immediately obvious.</p>
<h3 id="jump-address"><a class="header" href="#jump-address">Jump Address</a></h3>
<p>You can push a label, then jump to it like in the above example.</p>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<p>That's not all! You can also use labels to calculate lengths:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push1 start
push1 end
sub                 # &lt;- Will leave a 3 on the stack.
stop

start:
    pc
    pc
    pc
end:
<span class="boring">&quot;#;
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(Vec::new());
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>Calculating the length of a blob of instructions is <em>very</em> useful in contract initialization code (also known as constructors).</p>
<h1 id="macros-1"><a class="header" href="#macros-1">Macros</a></h1>
<p>A macro is a rule or pattern that maps a given input to a replacement output. In other words, the assembler replaces a <em>macro invocation</em> with some other text (the <em>macro expansion</em>.)</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Macros in ETK take one of two forms: instruction macros, and expression macros. Both types of macros are written as a name followed by arguments in parentheses.</p>
<h3 id="instruction-macros"><a class="header" href="#instruction-macros">Instruction Macros</a></h3>
<p>An instruction macro looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>%macro push_sum(a, b)
    push1 $a + $b
%end

%push_sum(4, 2)
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x06]);
</span><span class="boring">}
</span></code></pre></pre>
<p>Instruction macros always begin with <code>%</code>, and expand to one or more instructions. In this case, <code>%push_sum(4, 2)</code> would expand to:</p>
<pre><code class="language-ignore">push1 0x06
</code></pre>
<h3 id="expression-macros"><a class="header" href="#expression-macros">Expression Macros</a></h3>
<p>Expression macros <em>do not</em> begin with <code>%</code>, and cannot replace instructions. Instead, expression macros can be used in expressions. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>%def add_one(num)
    $num+1
%end

push1 add_one(41)
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x2a]);
</span><span class="boring">}
</span></code></pre></pre>
<p>Here, <code>add_one(...)</code> is an expression macro that returns the <code>num+1</code>. The fully expanded source would look like:</p>
<pre><code class="language-ignore">push1 42
</code></pre>
<h1 id="built-in-macros"><a class="header" href="#built-in-macros">Built-In Macros</a></h1>
<p>Built-in macros are implemented by the assembler, and provide additional features beyond basic instructions, constants, or labels.</p>
<h2 id="instruction-macros-1"><a class="header" href="#instruction-macros-1">Instruction Macros</a></h2>
<h3 id="import"><a class="header" href="#import"><code>%import(&quot;...&quot;)</code></a></h3>
<p>The <code>%import</code> macro expands to the instructions read from another file as if they had been typed here. The path is resolved relative to the current file.</p>
<h4 id="source-mainetk"><a class="header" href="#source-mainetk">Source: <code>main.etk</code></a></h4>
<pre><code class="language-ignore">push1 some_label
jump

%import(&quot;other.etk&quot;)
</code></pre>
<h4 id="source-otheretk"><a class="header" href="#source-otheretk">Source: <code>other.etk</code></a></h4>
<pre><code class="language-ignore">some_label:
    jumpdest
    stop
</code></pre>
<h4 id="after-expansion"><a class="header" href="#after-expansion">After Expansion</a></h4>
<pre><code class="language-ignore">push1 0x03
jump

jumpdest
stop
</code></pre>
<h3 id="include"><a class="header" href="#include"><code>%include(&quot;...&quot;)</code></a></h3>
<p>The <code>%include</code> macro expands to the instructions read from another file, but unlike <code>%import</code>, the included file is assembled independently from the current file:</p>
<ul>
<li>Labels from the included file are <em>not</em> available in the including file, and vise versa.</li>
<li>The address of the first instruction in the included file will be zero.</li>
</ul>
<p>The path is resolved relative to the current file.</p>
<h4 id="source-mainetk-1"><a class="header" href="#source-mainetk-1">Source: <code>main.etk</code></a></h4>
<pre><code class="language-ignore">some_label:                 # &lt;- Not visible in `other.etk`.
    push1 some_label        # &lt;- Pushes a zero on the stack.

%include(&quot;other.etk&quot;)
</code></pre>
<h4 id="source-otheretk-1"><a class="header" href="#source-otheretk-1">Source: <code>other.etk</code></a></h4>
<pre><code class="language-ignore">different_label:            # &lt;- Not visible in `main.etk`.
    push1 different_label   # &lt;- ALSO pushes a zero on the stack.
</code></pre>
<h4 id="after-expansion-1"><a class="header" href="#after-expansion-1">After Expansion</a></h4>
<pre><code class="language-ignore">push1 0x00
push1 0x00
</code></pre>
<h3 id="include_hex"><a class="header" href="#include_hex"><code>%include_hex(&quot;...&quot;)</code></a></h3>
<p>The <code>%include_hex</code> macro functions exactly like <code>%include</code>, except instead of assembling the given path, it includes the raw hexadecimal bytes.</p>
<h3 id="push"><a class="header" href="#push"><code>%push(...)</code></a></h3>
<p>The <code>%push</code> macro will expand to a reasonably sized <code>push</code> instruction for the given argument.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>%push(hello)

hello:
    jumpdest
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x02, 0x5b]);
</span><span class="boring">}
</span></code></pre></pre>
<p>Will look something like the following after expansion:</p>
<pre><code class="language-ignore">push1 0x02
jumpdest
</code></pre>
<h2 id="expression-macros-1"><a class="header" href="#expression-macros-1">Expression Macros</a></h2>
<h3 id="selector"><a class="header" href="#selector"><code>selector(&quot;...&quot;)</code></a></h3>
<p>The <code>selector</code> macro is useful when writing contracts that adhere to the <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector">Solidity ABI</a>. Specifically, the <code>selector</code> macro expands to the four byte selector of the given function signature.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push4 selector(&quot;transfer(address,uint256)&quot;)    # &lt;- expands to 0x63a9059cbb
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x63, 0xa9, 0x05, 0x9c, 0xbb]);
</span><span class="boring">}
</span></code></pre></pre>
<p>The fully expanded source would look like:</p>
<pre><code class="language-ignore">push4 0xa9059cbb
</code></pre>
<h3 id="topic"><a class="header" href="#topic"><code>topic(&quot;...&quot;)</code></a></h3>
<p>The <code>topic</code> macro is operates similiarly to <code>selector</code>, except it returns the entire 32 byte hash digest. This is useful for the <code>log</code> opcodes.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>push32 topic(&quot;transfer(address,uint256)&quot;)
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x7f, 169, 5, 156, 187, 42, 176, 158, 178, 25, 88, 63, 74, 89, 165, 208, 98, 58, 222, 52, 109, 150, 43, 205, 78, 70, 177, 29, 160, 71, 201, 4, 155]);
</span><span class="boring">}
</span></code></pre></pre>
<p>The fully expanded source would look like:</p>
<pre><code class="language-ignore">push32 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b
</code></pre>
<h1 id="expression-macros-2"><a class="header" href="#expression-macros-2">Expression Macros</a></h1>
<p>An <strong>expression macro</strong> is a type of expression which is resolved during assembly. This is useful for defining constant values or constant functions on values, such as defining getters on memory pointers.</p>
<h2 id="defining-an-expression-macro"><a class="header" href="#defining-an-expression-macro">Defining an Expression Macro</a></h2>
<p>Expression macros can accept an arbitrary number of parameters. Parameters are referenced within the macro definition by prepending <code>$</code> to the parameter's name.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>%def my_macro()
    42
%end

%def sum(x, y, z)
    $x+$y+$z
%end
<span class="boring">&quot;#;
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(Vec::new());
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="using-an-expression-macro"><a class="header" href="#using-an-expression-macro">Using an Expression Macro</a></h2>
<p>Expression macros can be invoked anywhere an expression is expected.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span><span class="boring">%def my_macro()
</span><span class="boring">   42
</span><span class="boring">%end
</span><span class="boring">%def sum(x, y, z)
</span><span class="boring">    $x+$y+$z
</span><span class="boring">%end
</span>push1 my_macro()
push1 sum(1, 2, my_macro())
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x2a, 0x60, 0x2d]);
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="instruction-macros-2"><a class="header" href="#instruction-macros-2">Instruction Macros</a></h1>
<p>An <strong>instruction macro</strong> is a type of macro that can expand to an arbitrary number of instructions. This is useful for defining routines that are repeated many times or routines with expressions that are parameterized.</p>
<h2 id="defining-an-instruction-macro"><a class="header" href="#defining-an-instruction-macro">Defining an Instruction Macro</a></h2>
<p>Instruction macros can accept an arbitrary number of parameters. Parameters are referenced within the macro definition by prepending <code>$</code> to the parameter's name.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span>%macro my_macro()
    push1 42
%end

%macro sum(x, y, z)
    push1 $x+$y+$z
%end
<span class="boring">&quot;#;
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(Vec::new());
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="using-a-instruction-macro"><a class="header" href="#using-a-instruction-macro">Using a Instruction Macro</a></h2>
<p>Expression macros can be invoked anywhere an instruction is expected.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate etk_asm;
</span><span class="boring">let src = r#&quot;
</span><span class="boring">%macro my_macro()
</span><span class="boring">   push1 42
</span><span class="boring">%end
</span><span class="boring">%macro sum(x, y, z)
</span><span class="boring">    push1 $x+$y+$z
</span><span class="boring">%end
</span>%my_macro()
%sum(1, 2, 3)
<span class="boring">&quot;#;
</span><span class="boring">let mut output = Vec::new();
</span><span class="boring">let mut ingest = etk_asm::ingest::Ingest::new(&amp;mut output);
</span><span class="boring">ingest.ingest(file!(), src).unwrap();
</span><span class="boring">assert_eq!(output, &amp;[0x60, 0x2a, 0x60, 0x06]);
</span><span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
